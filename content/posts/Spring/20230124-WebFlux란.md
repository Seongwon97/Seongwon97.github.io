---
title: "WebFlux란?"
date: 2023-01-24
tags: ["SpringFramework", "Reactive Programming", "WebFlux"]
draft: false
---

# 1. 비동기 웹 프레임워크의 장점 (Feat. Spring MVC의 한계)

Spring MVC와 같이 서블릿 기반의 웹 프레임워크는 매 연결마다 하나의 스레드를 사용하여 요청이 처리될 때, 작업 스레드가 종료될 때까지 요청 스레드들은 블로킹이 된다. 이러한 이유때문에 요청량의 증가에 따른 확장이 어려우며 작업 스레드가 스레드 풀로 반환되어 다른 요청의 처리를 준비하는데 많은 시간이 걸린다는 낭비도 발생하게 된다. Spring MVC와 다르게 비동기 웹 프레임워크는 적은 수의 스레드로 더 높은 확장성을 달성할 수 있다.

비동기 웹 프레임워크는 일반적으로 CPU 코어당 하나의 스레드를 만들어 사용하여도 이벤트 루핑(Event Looping)기법 덕분에 한 스레드당 많은 요청을 처리할 수 있어 Connection별 소모 비용이 적다. 이벤트 루프에서는 DB와 네트워크 작업 등 모든 작업을 이벤트로 처리한다. 비용이 드는 작업이 필요할 때는 해당 작업의 콜백(call back)을 등록하여 병행으로 수행하고 다른 이벤트로 넘어가며 작업이 완료되었을 때도 이벤트로 처리하게 된다. 즉, 모든 동작을 이벤트로 처리한다. 이러한 이벤트루프 덕분에 적은 양의 스레드로 많은 요청을 처리할 수 있어 스레드의 관리 부담이 줄고 확장성이 높다.

# 2. Spring WebFlux란?

Spring은 5.0 버전부터 WebFlux라는 [리액터(Reactor)](https://github.com/reactor/reactor)를 기반으로한 스프링의 리액티브 웹 프레임워크를 제공하고 있다. Spring WebFlux는 Spring MVC과는 분리된 프로젝트이지만 Spring MVC의 많은 핵심 컴포넌트들을 공유하고 있다.

> Reactor는 Spring WebFlux를 위한 반응형 라이브러리다. Mono, Flux의 데이터 타입을 제공하여 데이터 시퀀스에서 다양한 연산을 할 수 있는 기능을 제공하고 있다. 또한 리액터는 Reactive Stream 라이브러리이기 때문에 non-blocking back pressure를 제공하고 있다.
>

![Untitled](image/20230124-WebFlux란/img.png)

Spring WebFlux는 MVC와 다르게 서블릿 API와 연계되지 않고 동일한 기능의 리액티브 버전인 HTTP API의 상위 계층에 위치한다. 서블릿 API를 사용하지 않기에 서블릿 컨테이너가 필요하지 않으며 동작은 Netty, Undertow, Tomcat, Jetty 등의 **블로킹이 없는 웹 컨테이너**에서 실행된다. Spring WebFlux에서 기본적으로 내장 서버는 MVC와 다르게 Tomcat이 아닌 Netty를 사용한다.

> Netty는 비동기적인 이벤트 중심의 서버 중 하나이며 Spring WebFlux와 같은 리액티브 웹 프레임워크에 잘 맞는다.
>

> Spring MVC도 리액티브 타입을 사용 및 반환할 수 있다. 하지만 다중 스레드에 의존하여 처리하는 서블릿 기반의 프레임워크라 WebFlux의 이벤트 루프로 처리되는 리액티브 웹 프레임워크와는 사용 방법에 차이가 있다.
>

## 2.1. WebFlux의 성능

WebFlux와 MVC의 성능을 비교하면 리액티브와 논블로킹을 사용한다고 어플리케이션이 빨라지지는 않고 오히려 더 많은 작업이 필요해 처리 시간이 증가할 수가 있다. 하지만 블로킹이 발생할 수 있다는 특성을 갖고 요청별로 별도의 스레드를 사용하는 MVC에 비해 WebFlux는 이벤트루프 작업을 하는 작은 크기의 고정된 스레드를 사용하여 요청을 처리하기에 서비스를 확장하기 쉽다. 즉, WebFlux는 적은 양의 고정된 스레드와 적은 메모리로 기능을 확장할 수 있다는 점이 가장 큰 장점이다. 이는 어플리케이션의 탄력성을 높여준다.

# 3. 의존성 추가하기

```yaml
dependencies {
    implementation 'org.springframework.boot:spring-boot-starter-webflux'
}
```

# 4. Annotated Controllers 작성하기

```java
@RestController
@RequestMapping(path = "/design", produces = "application/json")
@CrossOrigin(origins = "*")
public class DesignTacoController {
  ...

  @GetMapping("/recent")
  public Flux<Taco> recentTacos() {
    return tacoRepo.findAll().take(12);
  }
}
```

컨트롤러 작성의 경우, Spring MVC와 핵심 컴포넌트들을 공유하고 있기에 큰 차이가 별로 없다. 단, 반환 값과 입력 값에서 차이가 발생한다. 먼저 반환 값을 살펴보겠다.

MVC의 경우 단일 값(value, Objcet) 또는 다중 값인 Iterable 타입을 반환하였다. 하지만 이러한 타입은 리액티브 타입이 아니라 리액티브 오퍼레이션도 적용할 수 없고 프레임워크가 해당 값들을 여러 스레드에 걸쳐 분할 작업을 할 수도 없게 된다. 그리하여 반환 값들을 Object, `Iterable`타입이 아닌 리액티브 타입인 `Mono`와 Flux`타입으로` 감싸주어 반환해줘야 한다.

컨트롤러에 보면 `subscribe()`를 호출하지 않는 것을 확인할 수 있다. 이는 프레임워크가 Repository로부터 `Flux`, `Mono`와 같은 리액티브 타입을 받을 때 호출해주기에 직접 호출할 필요가 없다.

> 리액티브 웹 프레임워크의 장점을 극대화하려면 컨트롤러의 반환뿐만 아니라 Repository-Service, Service-Controller 사이의 통신도 리액티브 타입을 사용해야 한다.
>

> 리액티브 타입의 경우 페이지네이션을 구현할 때 `take()`오퍼레이션을 이용하여 페이지의 크기를 제한할 수 있다.
>

다음으로 입력 값의 차이를 살펴보겠다.

```java
@RestController
@RequestMapping(path = "/design", produces = "application/json")
@CrossOrigin(origins = "*")
public class DesignTacoController {
  ...

  @PostMapping(consumes = "application/json")
  @ResponseStatus(HttpStatus.CREATED)
  public Mono<Taco> postTaco(@RequestBody Mono<Taco> taco) {
    return tacoRepo.saveAll(taco).next();
  }
}
```

MVC의 경우, 입력 값도 반환 값과 같이 `@RequestBody`로 객체를 받도록 구현하였다. 이와 같이 리액티브 타입이 아닌 객체로 받도록 구현하면 Request 객체를 `ObjectMapper`로부터 Request Body를 분석 후, 객체를 만들어지기까지 1번, Controller Method에서 Repository에 작업을 요청하고 응답이 오기까지 1번, 총 두 번의 블로킹이 발생하게 된다. 이는 RequestBody로 받는 객체의 타입을 리액티브 타입으로 변경하면 블로킹이 발생하지 않는 메서드로 만들 수 있다.

> 리액티브 컨트롤러의 테스트는 WebTestClient를 통해 테스트할 수 있다.
>

# 5. Functional Endpoints 만들기

WebFlux와 다르게 스프링 5는 함수형 프로그래밍 방식을 사용해 리액티브 API를 생성하는 방법도 제공하고 있다.

### Spring MVC의 어노테이션 방식의 문제점

1. 어노테이션 기반 프로그래밍은 “무엇을”하는지는 알지만 “어떻게” 하는지는 외부에 노출되지 않아 모델을 커스터마이징하거나 확장할 때 복잡해진다.
2. 어노테이션에 Break Point를 걸 수 없어서 디버깅을 하기 어렵다.
3. 스프링을 처음 접하는 개발자들은 학습이 필요하다.

이러한 단점을 보완하기 위해 새로운 프로그래밍 모델은 어노테이션을 사용하지 않고 요청을 핸들러 코드에 연관시켜 프레임워크보다는 라이브러리 형태로 사용하고 있다. 이러한 함수형 프로그래밍 모델의 API 작성에는 아래의 4가지 타입이 사용된다.

- `RequestPredicate`: 처리될 요청의 종류를 선언한다.
- `RouterFunction`: 일치하는 요청이 어떻게 핸들러에게 전달되어야 하는지를 선언한다.
- `ServerRequest`: HTTP 요청을 나타내며, 헤더와 몸체 정보를 사용할 수 있다.
- `ServerResponse`: HTTP 응답을 나타내며, 헤더와 몸체 정보를 포함한다.

```java
@Configuration
public class MemberRouterFunctionConfig {
   ...
    @Bean
    public RouterFunction<?> memberRouterFunction() {
        return route(GET("/api/members"), this::findMember)
                .andRoute(POST("/api/members"), this::signUp);
    }
   ...
}
```

사용 방법은 위의 클래스와 같이 `@Configuration`어노테이션을 붙은 클래스에 `RouterFunction`타입을 반환하는 메서드를 `@Bean`으로 등록하고 `RouterFunctions`의 `route()` 메서드를 통해 생성할 API들을 만들면 된다.

```java
public abstract class RouterFunctions {
   ...
   public static <T extends ServerResponse> RouterFunction<T> route(
			RequestPredicate predicate, HandlerFunction<T> handlerFunction) {

		return new DefaultRouterFunction<>(predicate, handlerFunction);
	}
}
```

`RouterFunctions`의 `route()` 메서드의 파라미터는 `RequestPredicate`과 `HandlerFunction`를 받고 있다. `RequestPredicate` 에는 앞서 설명하였듯이 처리될 요청의 종류를 대입하면 되며, `HandlerFunction`에는 해당 API가 호출되었을 때 동작하고 반환될 로직을 람다식 또는 메서드 참조를 통해 정의해주면 된다.

# 📚 Reference
- [🔗 Spring.io - WebFlux](https://docs.spring.io/spring-framework/docs/5.3.25/reference/html/web-reactive.html#webflux)
- [📕 Spring in Action](https://search.shopping.naver.com/book/catalog/32441616013?cat_id=50010920&frm=PBOKPRO&query=%EC%8A%A4%ED%94%84%EB%A7%81+%EC%9D%B8+%EC%95%A1%EC%85%98&NaPm=ct%3Dlda9nxco%7Cci%3Dd906c43162d8f7ea0058b5d8256de70e78a43e28%7Ctr%3Dboknx%7Csn%3D95694%7Chk%3D2751d7b7f4d90950bf02e054abfb3a756da88fab)
