---
title: "모두모여라 팀의 동시성 문제 해결 과정 (feat. Redis, 분산락)"
date: 2023-05-28
tags: ["SpringFramework", "JPA", "synchronized", "비관적락", "Pessimistic Lock", "낙관적락", "Optimistic Lock", "Redis", "분산락", "Reddisson"]
draft: false
---

이번 게시글은 모임 플랫폼인 모두모여라 프로젝트를 진행하며 동시성 문제를 해결한 과정에 대해 정리한 게시글입니다. 단일 서버에서 간단하게 해결한 방법으로부터 최종적으로 분산락을 적용한 과정까지 전 과정을 정리하였습니다. (앞의 과정은 간단히 설명하고 최종 적용한 분산락에 대해 자세히 설명하려 합니다.)

모두모여라 서비스의 모임 참여 기능은 모임 별로 주최자가 정한 모임의 인원 제한이 있습니다. 동시성 문제에 대한 아무런 처리가 없는 상황에서 여러 참여자가 동시에 참여 요청을 할 경우 모임의 제한 인원을 넘는 참여자가 생겨나는 문제가 발생하였습니다.

먼저 문제 상황을 알아보고자 기존 로직을 살펴보고 모임 참여에 대한 동시성 테스트 코드를 작성하며 테스트를 해보겠습니다. 모임 참여 로직을 살펴보면 아래와 같이 JPA를 통해 모임(Group)과 회원(Member) 정보를 데이터베이스에서 읽어온 후에 모임 참여를 진행하였습니다.

```java
@RequiredArgsConstructor
@Transactional(readOnly = true)
@Service
public class ParticipateService {

    private final MemberFindService memberFindService;
    private final GroupFindService groupFindService;

    @Transactional
    public void participate(Long groupId, Long memberId) {
        Group group = groupFindService.findGroup(groupId);
        Member member = memberFindService.findMember(memberId);

        group.participate(member);
    }
}
```

다음으로 테스트 코드입니다. 동시성 문제를 테스트하기 위해서는 동시 요청을 테스트코드로 작성해야하기에 `CountDownLatch`와 `ExecutorService`를 통해 별도의 스레드에서 참여로직이 동시에 처리되도록 하였습니다.

```java
@Sql(value = "classpath:init.sql", executionPhase = BEFORE_TEST_METHOD)
@Sql(value = "classpath:truncate.sql", executionPhase = AFTER_TEST_METHOD)
@TestConstructor(autowireMode = TestConstructor.AutowireMode.ALL)
@RequiredArgsConstructor
@SpringBootTest
class ParticipateServiceConcurrencyTest {

    private final ParticipateService participateService;
    private final GroupRepository groupRepository;
    private final MemberRepository memberRepository;

    private Member host;

    @BeforeEach
    void setUp() {
        this.host = memberRepository.save(MOMO.toMember());
    }

    @DisplayName("모임 참여 동시 요청이 올 경우에도 정원을 넘어선 인원이 모임에 참여할 수 없다")
    @Test
    void participateConcurrencyTest() throws InterruptedException {
        int capacity = 3;
        int numOfParticipants = 50;
        long groupId = groupRepository.save(
                MOMO_STUDY.builder()
                        .capacity(capacity)
                        .toGroup(host)
        ).getId();

        List<Long> participantIds = new ArrayList<>();
        for (int i = 0; i < numOfParticipants; i++) {
            Member savedMember = memberRepository.save(
                    new Member(UserId.momo("user" + i),
                            Password.encrypt("User123!", new SHA256Encoder()),
                            UserName.from("user" + i)));
            participantIds.add(savedMember.getId());
        }

        CountDownLatch latch = new CountDownLatch(numOfParticipants);
        ExecutorService executor = Executors.newFixedThreadPool(numOfParticipants);

        for (Long participantId : participantIds) {
            executor.submit(() -> {
                try {
                    participateService.participate(groupId, participantId);
                } finally {
                    latch.countDown();
                }
            });
        }

        executor.shutdown();
        latch.await();

        long actual = participateService.findParticipants(groupId).size();

        assertThat(actual).isEqualTo(capacity);
    }
}
```

결과를 살펴보면 아래와 같이 3명의 인원 제한이 있는 모임인데 11명의 참여자가 발생하게 되었습니다. 즉, 동시성 문제에 대한 제어가 필요한 상황입니다.

![Untitled](image/20230528-모두모여라_팀의_동시성문제_해결_과정/img.png)

# 해결 과정 1 - synchronized

첫번째 해결 책으로는 자바에서 하나의 스레드만이 임계 구역(Critical Section)에 접근하도록 지원해주는 `synchronized`를 통해 해결하였습니다. 단순히 기존 참여 메서드에 `synchronized`만 붙여주는 작업만으로도 기존에 발생하던 동시성 문제를 해결할 수 있었습니다.

## 코드 및 결과

```java
@RequiredArgsConstructor
@Transactional(readOnly = true)
@Service
public class ParticipateService {

    private final MemberFindService memberFindService;
    private final GroupFindService groupFindService;

    @Transactional
    public synchronized void participate(Long groupId, Long memberId) {
        Group group = groupFindService.findGroup(groupId);
        Member member = memberFindService.findMember(memberId);

        group.participate(member);
    }
}
```

![Untitled](image/20230528-모두모여라_팀의_동시성문제_해결_과정/img_1.png)

> 관련 PR: https://github.com/woowacourse-teams/2022-momo/pull/431
>

## 남아있는 문제

하지만 해당 방법은 단일 서버에서는 해결법이 될 수 있으나, N개의 서버를 운영하는 분산 환경에서는 각각의 서버에서 1개의 요청씩 동작시킨다 하더라도 전체적인 시스템을 보면 N개의 동일 요청이 실행되어 동시 접근을 제어하지 못하게 됩니다.

그럼 다중 서버에서 동시성 문제를 해결하는 방법은 무엇이 있을까요?? 이를 해결하기 위해서는 JPA에서 제공하는 **낙관적락**, 데이터베이스에 x-lock을 거는 **비관적락**, 락은 관리하는 외부 데이터베이스를 이용한 **분산락**이 존재합니다. 이 중에서 모두모여라 팀은 먼저 낙관적락과 비관적락을 고려하며 로직을 수정해봤습니다.

> 📌 해당 게시글은 프로젝트에서 발생한 문제를 기록하고 정리하는 게시글인 만큼 자세한 이론에 대해 다루지 않고 있습니다. 낙관적락, 비관적락, 분산락에 대해 자세히 알고싶으시면 아래의 포스트를 확인해주시기 바랍니다.
>
>
> [비관적 락(Pessimistic Lock)과 낙관적 락(Optimistic Lock)](https://seongwon.dev/Spring-MVC/20230430-비관적락과_낙관적락/)
>
> [Redis를 통한 분산락(Distribution Lock)으로 동시성 문제 제어하기](https://seongwon.dev/MSA/20230503-Redis를_통한_분산락으로_동시성_문제_제어하기/)
>

# 해결 과정 2 - 비관적 락 vs 낙관적 락

우리 팀은 서비스의 특성을 고려하여 낙관적 락과 비관적 락 중 비관적 락을 선택 및 적용하였습니다. 선택 이유는 충돌에 대한 잦은 롤백 처리로 인해 성능이 더 안 좋아질 수 있기 때문이었다.

이해를 돕기 위해 상황 예시를 한번 들어보겠습니다. 10명만 참여 가능한 모임 서비스에 낙관적 락이 걸려있고 1000명이 동시 요청을 하였다 가정하면 최초로 데이터베이스에 Commit 요청이 처리된 1명은 통과하며 엔티티의 버전을 변경하게 됩니다. 그리고 이후의 남은 999명은 업데이트 시점에 버전을 확인하였는데 버전이 변경되었기에 취소되고 애플리케이션에서 오류 처리 로직에 따라 다시 재시도를 요청하게 됩니다. 그리고 다음 한명이 요청을 처리하게되고 남은 998명은 다시 새로운 버전을 읽고 재시도를 해야한다…(반복)

이와 같이 인기 있는 모임에 참여 동시 요청이 발생할 경우, 잦은 충돌로 인한 낙관적 락의 오류 처리 비용으로 인해 성능에 더 영향을 줄 것이라 판단해 비관적 락을 택하였습니다.

## 코드 및 결과

비관적 락을 적용한 코드는 아래와 같습니다.

```java
public interface GroupSearchRepository extends Repository<Group, Long>, GroupSearchRepositoryCustom {

    @Lock(value = LockModeType.PESSIMISTIC_WRITE)
    @Query("select g from Group g where g.id = :id")
    Optional<Group> findByIdForUpdate(@Param("id") Long id);
    
    ...
}
```

```java
@RequiredArgsConstructor
@Transactional(readOnly = true)
@Service
public class GroupFindService {

    private final GroupSearchRepository groupSearchRepository;
    private final ParticipantRepository participantRepository;

    ...

    public Group findByIdForUpdate(Long id) {
        return groupSearchRepository.findByIdForUpdate(id)
                .orElseThrow(() -> new GroupException(NOT_EXIST));
    }
    ...
}
```

```java
@RequiredArgsConstructor
@Transactional(readOnly = true)
@Service
public class ParticipateService {

    private final MemberFindService memberFindService;
    private final GroupFindService groupFindService;

    @Transactional
    public void participate(Long groupId, Long memberId) {
        Group group = groupFindService.findByIdForUpdate(groupId);
        Member member = memberFindService.findMember(memberId);

        group.participate(member);
    }
    ...
}
```

![Untitled](image/20230528-모두모여라_팀의_동시성문제_해결_과정/img_2.png)

테스트를 실행한 결과 정상적으로 통과하며 문제를 해결할 수 있었습니다.

## 남아있는 문제

비관적 락을 적용하며 다중 서버에서 동시성 문제를 해결할 수는 있었으나 데이터 베이스에 x-lock을 걸게 되며 쓰기 뿐만 아니라 데이터 조회에도 영향을 주는 문제가 발생했습니다.

```java
@RequiredArgsConstructor
@Transactional(readOnly = true)
@Service
public class ParticipateService {

    private final MemberFindService memberFindService;
    private final GroupFindService groupFindService;

    @Transactional
    public void participate(Long groupId, Long memberId) {
        // findByIdForUpdate -> SELECT FOR UPDATE를 통한 x-lock 획득
        Group group = groupFindService.findByIdForUpdate(groupId);
        Member member = memberFindService.findMember(memberId);
        // group 객체는 capacity와 참여자의 정보를 얻기 위한 그래프 탐색을 하기 위해 획득
        // group 테이블에는 변경 X, Participants 테이블에만 새로운 참가자 데이터가 추가됨
        group.participate(member);
    }
}
```

위의 로직을 살펴보면 `participate()` 메서드가 실행됨과 동시에 `SELECT FOR UPDATE`를 통해 Group정보를 얻으며 해당 데이터에 x-lock을 걸며 다른 읽기, 쓰기 요청에 대한 모든 접근을 제한하였습니다. **즉, 모임 참여 요청을 처리하는 과정에서 모임 테이블에 변동을 주지 않음에도 불구하고 모임 조회에 대한 접근도 막게 되며 조회 성능에도 영향을 주게 된겁니다.**

# 📚 Reference
