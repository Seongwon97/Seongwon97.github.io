{"componentChunkName":"component---src-templates-category-js","path":"/Spring-WebFlux/","result":{"data":{"site":{"siteMetadata":{"configs":{"countOfInitialPost":10}}},"allMarkdownRemark":{"edges":[{"node":{"excerpt":"해당 게시글은 projectreactor.io에서 제공하는 문서를 번역한 글입니다. 각각의 오퍼레이터들의 확실한 동작에 대해 살펴보기보다 “이런 상황에는 이런 메서드를 사용해야하는구나!”, “이런 메서드들도 존재하구나!”와 같은 배움을 얻기 위해 문서를 읽으며 간단히 번역해봤습니다. 아직 사용해보지 못한 오퍼레이터들이 많아 번역한 글이 미흡할 수 있는 점…","fields":{"slug":"/Spring-WebFlux/20230216-상황별_사용해야하는_Operator_정리/"},"frontmatter":{"date":"2023년 02월 16일","title":"[Reactor] 상황별 사용해야하는 Operator 정리","tags":["SpringFramework","Reactive Programming","Reactor"]}}},{"node":{"excerpt":"1. 비동기 웹 프레임워크의 장점 (Feat. Spring MVC의 한계) Spring MVC와 같이 서블릿 기반의 웹 프레임워크는 매 연결마다 하나의 스레드를 사용하여 요청이 처리될 때, 작업 스레드가 종료될 때까지 요청 스레드들은 블로킹이 된다. 이러한 이유때문에 요청량의 증가에 따른 확장이 어려우며 작업 스레드가 스레드 풀로 반환되어 다른 요청의 처…","fields":{"slug":"/Spring-WebFlux/20230124-WebFlux란/"},"frontmatter":{"date":"2023년 01월 24일","title":"WebFlux란?","tags":["SpringFramework","Reactive Programming","WebFlux"]}}},{"node":{"excerpt":"리액티브 프로그래밍이란? Spring을 통한 백엔드 개발을 시작하게 된다면 대부분의 개발자들은 MVC를 통한 블로킹 코드로 개발을 진행할 것이다. 블로킹 코드의 경우 데이터베이스의 접근, 또는 다른 API의 호출과 같은 작업을 진행한다면 해당 작업이 완료될 때까지 대기 상태로 기다리는 낭비가 발생하게 된다. 이러한 성능을 향상시키기 위해서는 스레드를 병렬…","fields":{"slug":"/Spring-WebFlux/20230120-Reactive-Programming/"},"frontmatter":{"date":"2023년 01월 20일","title":"리액티브 프로그래밍과 리액티브 스트림","tags":["SpringFramework","Reactive Programming","Publisher","Subscriber","Subscription","Processor"]}}}]}},"pageContext":{"categoryRegex":"/^(/home/runner/work/Seongwon97.github.io/Seongwon97.github.io/content/posts/)(Spring-WebFlux/)([^/]*.md$)/"}},"staticQueryHashes":["1900723382","3911196313","4111100897"]}