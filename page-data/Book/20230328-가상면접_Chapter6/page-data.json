{"componentChunkName":"component---src-templates-blog-post-js","path":"/Book/20230328-가상면접_Chapter6/","result":{"data":{"site":{"siteMetadata":{"author":"Seongwon","comment":{"utterances":"Seongwon97/Seongwon97.github.io"},"sponsor":{"buyMeACoffeeId":"seongwon"}}},"markdownRemark":{"excerpt":"키-값 저장소는 키-값 데이터베이스라고도 불리는 비 관계형 데이터베이스이다. 키-값 저장소에서는 값은 키와 쌍(pair)을 이루고 있으며 키는 고유 식별자여야 한다. 또한 값은 어떤 데이터가 오던지 상관 없다. 대표적으로는 아마존 다이나모, memcached, Redis 같은 것들이 있다. 문제 이해 및 설계 범위 확정 해당 책에서는 시스템을 설계하기 앞…","html":"<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 912px; \"\n    >\n      <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 131.66666666666666%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAaCAYAAAC3g3x9AAAACXBIWXMAAAsTAAALEwEAmpwYAAAB0klEQVRIx+2UXUojQRDH5/s7yTiT+dzEREUFFUkIMeq6q9kNgooIAcUXBQ/go4fwDN7DC3gGb+CTl/hb1SPR4LKwrruI+FB0T3fXr6r/XTWSJEl4Y/sE/g+gokpQtfec4cl5jovLKQSRXqzJrwDKj04TVR03dyu4Rx+Dg3AkwasztGwFV9cLuL7tYKnjFcGUv7yyqsowLeWzsD800DAV8dJ/BOTaUjV5VNDPi3t6zkWr68NxVQJL0HS56G8yRSlsDKhQ9Jl5F/UpG7WGRXNHWHPWwfySi8VWCd2vPpLcRHlCEy3I8yg1kdYsfJm0RbAR0CtpWNsKxIHGtINvgxDr/QDtVR/93Sq6Gz42BgHqTVs4eWUNGYGqiYk4sxBGBvxAfwIyfW0zQF63xGJv08fhWYbhaUoZetjaCbF/nGB4ktJ6jr2jWKwNTzPoRqEtA1kyAXQ9Fe2eL6Jy7/IPgeEsQUDRo9RArWmRBLYYOSOHfGK6EbekRiAGPmopwXZUITofWO5U8HMvQmulQlbG9+2QrhtisV3C+g+SoVcRcnA2fLNaw6Egjgg89soJaZHmFoKqQdqQxYbIhMckM0fzMB7f42/24Zd/UYdcJr+y3+3J8j/ulAeVMTK7lFneOQAAAABJRU5ErkJggg=='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"Untitled\"\n        title=\"Untitled\"\n        src=\"/static/4d0c6b0a13788d3977702c683728c64c/8b69f/%EA%B0%80%EC%83%81_%EB%A9%B4%EC%A0%91_%EC%82%AC%EB%A1%80%EB%A1%9C_%EB%B0%B0%EC%9A%B0%EB%8A%94_%EB%8C%80%EA%B7%9C%EB%AA%A8_%EC%8B%9C%EC%8A%A4%ED%85%9C_%EC%84%A4%EA%B3%84_%EA%B8%B0%EC%B4%88.png\"\n        srcset=\"/static/4d0c6b0a13788d3977702c683728c64c/5a46d/%EA%B0%80%EC%83%81_%EB%A9%B4%EC%A0%91_%EC%82%AC%EB%A1%80%EB%A1%9C_%EB%B0%B0%EC%9A%B0%EB%8A%94_%EB%8C%80%EA%B7%9C%EB%AA%A8_%EC%8B%9C%EC%8A%A4%ED%85%9C_%EC%84%A4%EA%B3%84_%EA%B8%B0%EC%B4%88.png 300w,\n/static/4d0c6b0a13788d3977702c683728c64c/0a47e/%EA%B0%80%EC%83%81_%EB%A9%B4%EC%A0%91_%EC%82%AC%EB%A1%80%EB%A1%9C_%EB%B0%B0%EC%9A%B0%EB%8A%94_%EB%8C%80%EA%B7%9C%EB%AA%A8_%EC%8B%9C%EC%8A%A4%ED%85%9C_%EC%84%A4%EA%B3%84_%EA%B8%B0%EC%B4%88.png 600w,\n/static/4d0c6b0a13788d3977702c683728c64c/8b69f/%EA%B0%80%EC%83%81_%EB%A9%B4%EC%A0%91_%EC%82%AC%EB%A1%80%EB%A1%9C_%EB%B0%B0%EC%9A%B0%EB%8A%94_%EB%8C%80%EA%B7%9C%EB%AA%A8_%EC%8B%9C%EC%8A%A4%ED%85%9C_%EC%84%A4%EA%B3%84_%EA%B8%B0%EC%B4%88.png 912w\"\n        sizes=\"(max-width: 912px) 100vw, 912px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n      />\n    </span></p>\n<p>키-값 저장소는 키-값 데이터베이스라고도 불리는 비 관계형 데이터베이스이다.</p>\n<p>키-값 저장소에서는 값은 키와 쌍(pair)을 이루고 있으며 키는 고유 식별자여야 한다. 또한 값은 어떤 데이터가 오던지 상관 없다.</p>\n<p>대표적으로는 아마존 다이나모, memcached, Redis 같은 것들이 있다.</p>\n<h1 id=\"문제-이해-및-설계-범위-확정\" style=\"position:relative;\"><a href=\"#%EB%AC%B8%EC%A0%9C-%EC%9D%B4%ED%95%B4-%EB%B0%8F-%EC%84%A4%EA%B3%84-%EB%B2%94%EC%9C%84-%ED%99%95%EC%A0%95\" aria-label=\"문제 이해 및 설계 범위 확정 permalink\" class=\"toc-header before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>문제 이해 및 설계 범위 확정</h1>\n<blockquote>\n<p>해당 책에서는 시스템을 설계하기 앞서 요구사항을 정리한다. 아래의 요구사항은 해당 시스템을 만들기 위해 항상 필요한 요구사항이 아닌 예시임을 참고하자.</p>\n</blockquote>\n<ul>\n<li>키-값 쌍의 크기는 10KB 이하이다.</li>\n<li>큰 데이터를 저장할 수 있어야 한다.</li>\n<li>높은 가용성을 제공해야 한다. → 장애가 발생하여도 빨리 응답해야 한다.</li>\n<li>높은 규모 확장성을 제공해야 한다. → 트래픽 양에 따라 자동적으로 서버의 증설/삭제가 이루어져야 한다.</li>\n<li>데이터 일관성 수준은 조정이 가능해야 한다.</li>\n<li>응답 지연시간이 짧아야 한다.</li>\n</ul>\n<h1 id=\"단일-서버-키-값-저장소\" style=\"position:relative;\"><a href=\"#%EB%8B%A8%EC%9D%BC-%EC%84%9C%EB%B2%84-%ED%82%A4-%EA%B0%92-%EC%A0%80%EC%9E%A5%EC%86%8C\" aria-label=\"단일 서버 키 값 저장소 permalink\" class=\"toc-header before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>단일 서버 키-값 저장소</h1>\n<p>가장 쉬운 설계 방법이며 빠른 속도를 보장한다. 하지만 모든 데이터를 메모리안에 두는 것이 불가능할 수도 있다는 단점을 갖고 있다.</p>\n<p>메모리 부족의 문제의 해결법으로는 <strong>데이터 압축</strong>과 <strong>자주 쓰이는 데이터만 메모리에 올리고 다른 데이터는 디스크에 저장</strong>하는 방법이 있다.</p>\n<p>해당 방법을 사용해도 부족하다면 분산 키-값 저장소를 만들어야 한다.</p>\n<h1 id=\"분산-키-값-저장소\" style=\"position:relative;\"><a href=\"#%EB%B6%84%EC%82%B0-%ED%82%A4-%EA%B0%92-%EC%A0%80%EC%9E%A5%EC%86%8C\" aria-label=\"분산 키 값 저장소 permalink\" class=\"toc-header before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>분산 키-값 저장소</h1>\n<p>분산 키-값 저장소는 분산 해시 테이블이라고도 불린다. 분산된 저장소에서는 CAP정리에 따라 모든 요구사항을 만족할 수는 없고 상황에 따라 한 가지 요구사항은 희생하여야 한다.</p>\n<h2 id=\"cap-정리\" style=\"position:relative;\"><a href=\"#cap-%EC%A0%95%EB%A6%AC\" aria-label=\"cap 정리 permalink\" class=\"toc-header before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a><strong>CAP 정리</strong></h2>\n<p>CAP 정리는 아래의 3가지 요구사항을 동시에 만드는 분산 시스템을 설계하는 것은 불가능하다는 정리이다.</p>\n<ul>\n<li><strong>Consistency(일관성)</strong> : 클라이언트는 어떤 노드에 접속하던간에 같은 데이터를 받아야 한다.</li>\n<li><strong>Availability(가용성)</strong> : 일부 노드에 장애가 발생하더라도 클라이언트는 항상 응답을 받을 수 있어야 한다.</li>\n<li><strong>Partition Tolerance(파티션 감내)</strong> : 노드 사이에 통신 장애가 발생한 파티션이 발생하여도 시스템은 계속 동작해야 한다.</li>\n</ul>\n<h1 id=\"시스템-컴포넌트\" style=\"position:relative;\"><a href=\"#%EC%8B%9C%EC%8A%A4%ED%85%9C-%EC%BB%B4%ED%8F%AC%EB%84%8C%ED%8A%B8\" aria-label=\"시스템 컴포넌트 permalink\" class=\"toc-header before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>시스템 컴포넌트</h1>\n<p>키-값 저장소 구현에는 아래의 핵심 컴포넌트들이 사용된다.</p>\n<h2 id=\"데이터-파티션\" style=\"position:relative;\"><a href=\"#%EB%8D%B0%EC%9D%B4%ED%84%B0-%ED%8C%8C%ED%8B%B0%EC%85%98\" aria-label=\"데이터 파티션 permalink\" class=\"toc-header before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>데이터 파티션</h2>\n<ul>\n<li>대규모 서비스에서는 전체 데이터를 한 개의 서버에 넣는건 무리가 있어서 작은 파티션으로 나누어 여러 서배에 분할하여 저장한다.</li>\n<li>데이터를 파티션으로 나눌 때는 데이터를 고르게 분산시키는 점과 노드의 추가, 삭제시 발생하는 데이터 이동 문제를 고려해야하는데 이는 <strong>안정 해시(consistent hash)</strong>를 통해 해결할 수 있다.</li>\n</ul>\n<h2 id=\"데이터-다중화-replication\" style=\"position:relative;\"><a href=\"#%EB%8D%B0%EC%9D%B4%ED%84%B0-%EB%8B%A4%EC%A4%91%ED%99%94-replication\" aria-label=\"데이터 다중화 replication permalink\" class=\"toc-header before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>데이터 다중화 (Replication)</h2>\n<ul>\n<li>높은 가용성과 안정성을 확보하기 위해서는 데이터를 N개의 서버에 비동기적으로 다중화를 해둬야 한다.</li>\n<li>서버 선정 방법: 키를 해시 링 위에 배치한 후, 시계방향으로 순회하며 만나는 N개의 물리 서버에 저장한다.</li>\n</ul>\n<h2 id=\"일관성-consistency\" style=\"position:relative;\"><a href=\"#%EC%9D%BC%EA%B4%80%EC%84%B1-consistency\" aria-label=\"일관성 consistency permalink\" class=\"toc-header before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>일관성 (Consistency)</h2>\n<ul>\n<li>데이터들은 여러 노드에 다중화가 되어 있어 동기화를 하여야 한다. 동기화는 <strong>정족수 합의(Quorum Consensus) 프로토콜</strong>을 사용하면 읽기/쓰기 연산에 모두 일관성을 보장할 수 있다.</li>\n<li>\n<p>정족수 합의에서는 응답 지연시간과 데이터 일관성의 타협점을 찾아 W, R, N의 값을 설정하여 진행한다. W와 R은 1보다 클 경우 일관성의 수준은 향상되지만 응답 속도는 줄어들 것이다. 이에 시스템에 맞는 적절한 값을 정하는 것이 좋다. 일반적으로 <code>W + R > N</code> 인 경우, 강한 일관성(Strong Consistency)이 보장된다.</p>\n<ul>\n<li>N = 사본의 개수</li>\n<li>W = 쓰기 연산에 대한 정족수로 쓰기 연산이 성공하려면 중재자가 W개 이상의 서버로부터 성공했다는 응답을 받아야 한다.</li>\n<li>R = 읽기 연산에 대한 정족수로 읽기 연산이 성공하려면 중재자가 R개 이상의 서버로부터 응답을 받아야 한다.</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"일관성-불일치-해소-inconsistency-resolution\" style=\"position:relative;\"><a href=\"#%EC%9D%BC%EA%B4%80%EC%84%B1-%EB%B6%88%EC%9D%BC%EC%B9%98-%ED%95%B4%EC%86%8C-inconsistency-resolution\" aria-label=\"일관성 불일치 해소 inconsistency resolution permalink\" class=\"toc-header before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>일관성 불일치 해소 (Inconsistency Resolution)</h2>\n<ul>\n<li>일관성 모델에는 클라이언트가 항상 최신의 결과를 반환받는 <strong>강한 일관성(Strong Consistency)</strong>, 항상 최신의 결과를 반환받지 못할 수 있는 <strong>약한 일관성(Weak Consistency)</strong>, 그리고 약한 일관성의 한 형태로 갱신 결과가 최종적으로는 모든 사본에 동기화되는 것을 보장하는 <strong>최종 일관성(Eventual Consistency)</strong>모델이 있다.</li>\n<li>다이나모, 카산드라의 경우 최종 일관성 모델을 채택하고 있다.</li>\n<li>\n<p>최종 일관성 모델의 경우 쓰기 연산이 병렬적으로 발생하면 일관성이 꺠질 수 있는데 이는 클라이언트가 해결해야 한다. 해결 방법 중에서는 <strong>데이터 버저닝(Data Versioning)</strong>와 <strong>벡터 시계(Vector Clock)</strong>를 통해 해결할 수 있다.</p>\n<ul>\n<li>데이터 버저닝 : 데이터를 변경할 때마다 해당 데이터의 새로운 버전을 만드는 것을 의미한다.</li>\n<li>\n<p>벡터 시계 :  [서버, 버전]의 순서쌍을 데이터에 매단 것으로 어떤 버전이 선행 버전인지 후행버전인지, 그리고 버전의 충돌이 있는지 판별하는데 사용된다.</p>\n<ul>\n<li>문제점 1: 충돌 감지 및 해소 로직이 클라이언트에 들어가야 하여 클라이언트 구현이 복잡해진다.</li>\n<li>문제점 2: [서버:버전]의 순서쌍 개수가 굉장히 빨리 늘어난다.</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"장애-처리\" style=\"position:relative;\"><a href=\"#%EC%9E%A5%EC%95%A0-%EC%B2%98%EB%A6%AC\" aria-label=\"장애 처리 permalink\" class=\"toc-header before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>장애 처리</h2>\n<ul>\n<li>분산 시스템에서는 특정 노드에 장애가 발생하였을 때, 2개 이상의 서버가 보고해야 장애가 발생했다고 간주한다.</li>\n<li>\n<p>장애 감지는 분산형 장애감지 솔루션인 <strong>가십 프로토콜(gossip protocol)</strong>을 사용하는 것이 효율적이다.</p>\n<ul>\n<li>각 노드는 멤버 ID와 Heartbeat counter쌍을 가진 멤버십 목록을 유지한다.</li>\n<li>각 노드는 주기적으로 자신의 박동 카운터를 증가시키고 무작위로 선정된 노드들에게 주기적으로 자신의 박동 카운터 목록을 보낸다.</li>\n<li>박동 카운터 목록을 받은 노드는 멤버십 목록을 최신 값으로 갱신한다.</li>\n<li>하지만 어떤 멤버의 박동 카운터 값이 지정된 시간 동안 갱신되지 않았다면 해당 멤버는 장애인 것으로 판단한다.</li>\n</ul>\n</li>\n<li>\n<p>장애 처리는 일시적 장애 처리와 영구적 장애 처리가 존재한다.</p>\n<ul>\n<li>일시적 장애 처리 - <strong>느슨한 정족수(Sloppy quorum)</strong> 프로토콜을 사용하고 <strong>단서 후 임시 위탁(hinted handoff) 기법</strong>에 따라 네트워크나 서버 문제로 장애 상태인 서버로 가는 요청은 다른 서버가 잠시 맡아서 처리를 하게 된다. 그리고 해당 서버가 복구된다면 일괄 반영하여 일관성을 보존하게 된다.</li>\n<li>영구 장애 처리 - <strong>반 엔트로피(anti-entropy) 프로토콜</strong>을 구현하여 사본들을 동기화한다. 반 엔트로피 프로토콜은 <strong>Merkle트리(aka.Hash tree)</strong>를 사용하여 탐색과 전송 데이터의 양을 줄인다.</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"시스템-아키택처\" style=\"position:relative;\"><a href=\"#%EC%8B%9C%EC%8A%A4%ED%85%9C-%EC%95%84%ED%82%A4%ED%83%9D%EC%B2%98\" aria-label=\"시스템 아키택처 permalink\" class=\"toc-header before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>시스템 아키택처</h2>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 1200px; \"\n    >\n      <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 55.00000000000001%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAALCAYAAAB/Ca1DAAAACXBIWXMAAAsTAAALEwEAmpwYAAABeElEQVQoz41Ty26DMBDk/9VP6LlfUantpYeqTRUplzwahVYQEkJCePiF7enaEETSKOpKi8EsszOzJsCNsNb69KEFRDIG5xyMMdR17VchxFl9cAtsuLJDjOTlDkY3fY2xBg29jl/vIaM3vxecWAwBLsFU04AVJW10zVxqDSs4IDX4Zop6//MXsJc3APPsSJohidaYFohxSgarFNUZXyOVhpLyr+Q8z5FlWSuJABoCUARGZhEjSi48aN+4uzaNIn8ZgtlshvF4jCRJvNFhGGK1WqEoChyqCvH7B9ZPz+DUxFa1l+mZOaZkxQnceGsMAienLMt+WmmaIoqiznQLQ4zC+RxxHDsf4BU6EAJ1aYkV6PE4fcTu8+Fc8jUPbTeUPmROTbfY7fdINhvyTrY+Z99g6fx/U5ZkdkXyjWPGt1jHERaLLxTHY3tEjQYTqp3ytXM3ZOoG42IymXivh+EaLZfL9hR4L28c7EtwTR84n3n3l7h75/doNDqr/wWbNlq6vZkBngAAAABJRU5ErkJggg=='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"Untitled\"\n        title=\"Untitled\"\n        src=\"/static/771b359722c01355584062cf2630c69a/c1b63/img.png\"\n        srcset=\"/static/771b359722c01355584062cf2630c69a/5a46d/img.png 300w,\n/static/771b359722c01355584062cf2630c69a/0a47e/img.png 600w,\n/static/771b359722c01355584062cf2630c69a/c1b63/img.png 1200w,\n/static/771b359722c01355584062cf2630c69a/d61c2/img.png 1800w,\n/static/771b359722c01355584062cf2630c69a/d369e/img.png 1815w\"\n        sizes=\"(max-width: 1200px) 100vw, 1200px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n      />\n    </span></p>\n<ul>\n<li>클라이언트는 키-값 저장소가 제공하는 get(key), put(key, value) API를 제공한다.</li>\n<li>중재자는 클라이언트에게 키-값 저장소에 대한 Proxy역할을 하는 노드이다.</li>\n<li>노드는 안정해시의 해시링에 분포한다.</li>\n<li>노드를 자동으로 추가 또는 삭제할 수 있도록 시스템은 완전히 분산된다.</li>\n<li>데이터는 여러 노드에 다중화된다.</li>\n</ul>\n<h2 id=\"쓰기-경로\" style=\"position:relative;\"><a href=\"#%EC%93%B0%EA%B8%B0-%EA%B2%BD%EB%A1%9C\" aria-label=\"쓰기 경로 permalink\" class=\"toc-header before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>쓰기 경로</h2>\n<p>쓰기 요청이 특정 노드에 전달되면 다음과 같이 동작한다. 예시는 카산드라의 사례이다.</p>\n<ol>\n<li>쓰기 요청이 Commit log 파일에 기록된다.</li>\n<li>데이터가 메모리 캐시에 기록된다.</li>\n<li>메모리 캐시가 가득차거나 사전에 정의된 임계치에 도달하면 데이터는 디스크에 있는 SSTable에 기록된다. (SSTable(Sorted-String Table)은 &#x3C;키, 값>의 순서쌍을 정렬된 리스트 형태로 관리하는 테이블이다.)</li>\n</ol>\n<h2 id=\"읽기-경로\" style=\"position:relative;\"><a href=\"#%EC%9D%BD%EA%B8%B0-%EA%B2%BD%EB%A1%9C\" aria-label=\"읽기 경로 permalink\" class=\"toc-header before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>읽기 경로</h2>\n<p>데이터를 읽을 때는 어떤 SSTable에 키가 있는지 알아내기 위해 일반적으로 <strong>블룸 필터(Bloom Filter)</strong>를 흔히 사용한다.</p>\n<ol>\n<li>데이터가 메모리에 있는지 검사한다. 없으면 2로 간다.</li>\n<li>데이터가 메모리에 없으므로 블룸 필터를 검사한다.</li>\n<li>블룸 필터를 통해 어떤 SSTable에 키가 보관되어 있는지 알아낸다.</li>\n<li>SSTable에서 데이터를 가져온다.</li>\n<li>해당 데이터를 클라이언트에게 반환한다.</li>\n</ol>\n<style class=\"grvsc-styles\">\n  .grvsc-container {\n    overflow: auto;\n    position: relative;\n    -webkit-overflow-scrolling: touch;\n    padding-top: 1rem;\n    padding-top: var(--grvsc-padding-top, var(--grvsc-padding-v, 1rem));\n    padding-bottom: 1rem;\n    padding-bottom: var(--grvsc-padding-bottom, var(--grvsc-padding-v, 1rem));\n    border-radius: 8px;\n    border-radius: var(--grvsc-border-radius, 8px);\n    font-feature-settings: normal;\n    line-height: 1.4;\n  }\n  \n  .grvsc-code {\n    display: table;\n  }\n  \n  .grvsc-line {\n    display: table-row;\n    box-sizing: border-box;\n    width: 100%;\n    position: relative;\n  }\n  \n  .grvsc-line > * {\n    position: relative;\n  }\n  \n  .grvsc-gutter-pad {\n    display: table-cell;\n    padding-left: 0.75rem;\n    padding-left: calc(var(--grvsc-padding-left, var(--grvsc-padding-h, 1.5rem)) / 2);\n  }\n  \n  .grvsc-gutter {\n    display: table-cell;\n    -webkit-user-select: none;\n    -moz-user-select: none;\n    user-select: none;\n  }\n  \n  .grvsc-gutter::before {\n    content: attr(data-content);\n  }\n  \n  .grvsc-source {\n    display: table-cell;\n    padding-left: 1.5rem;\n    padding-left: var(--grvsc-padding-left, var(--grvsc-padding-h, 1.5rem));\n    padding-right: 1.5rem;\n    padding-right: var(--grvsc-padding-right, var(--grvsc-padding-h, 1.5rem));\n  }\n  \n  .grvsc-source:empty::after {\n    content: ' ';\n    -webkit-user-select: none;\n    -moz-user-select: none;\n    user-select: none;\n  }\n  \n  .grvsc-gutter + .grvsc-source {\n    padding-left: 0.75rem;\n    padding-left: calc(var(--grvsc-padding-left, var(--grvsc-padding-h, 1.5rem)) / 2);\n  }\n  \n  /* Line transformer styles */\n  \n  .grvsc-has-line-highlighting > .grvsc-code > .grvsc-line::before {\n    content: ' ';\n    position: absolute;\n    width: 100%;\n  }\n  \n  .grvsc-line-diff-add::before {\n    background-color: var(--grvsc-line-diff-add-background-color, rgba(0, 255, 60, 0.2));\n  }\n  \n  .grvsc-line-diff-del::before {\n    background-color: var(--grvsc-line-diff-del-background-color, rgba(255, 0, 20, 0.2));\n  }\n  \n  .grvsc-line-number {\n    padding: 0 2px;\n    text-align: right;\n    opacity: 0.7;\n  }\n  \n</style>","tableOfContents":"<ul>\n<li><a href=\"/Book/20230328-%EA%B0%80%EC%83%81%EB%A9%B4%EC%A0%91_Chapter6/#%EB%AC%B8%EC%A0%9C-%EC%9D%B4%ED%95%B4-%EB%B0%8F-%EC%84%A4%EA%B3%84-%EB%B2%94%EC%9C%84-%ED%99%95%EC%A0%95\">문제 이해 및 설계 범위 확정</a></li>\n<li><a href=\"/Book/20230328-%EA%B0%80%EC%83%81%EB%A9%B4%EC%A0%91_Chapter6/#%EB%8B%A8%EC%9D%BC-%EC%84%9C%EB%B2%84-%ED%82%A4-%EA%B0%92-%EC%A0%80%EC%9E%A5%EC%86%8C\">단일 서버 키-값 저장소</a></li>\n<li>\n<p><a href=\"/Book/20230328-%EA%B0%80%EC%83%81%EB%A9%B4%EC%A0%91_Chapter6/#%EB%B6%84%EC%82%B0-%ED%82%A4-%EA%B0%92-%EC%A0%80%EC%9E%A5%EC%86%8C\">분산 키-값 저장소</a></p>\n<ul>\n<li><a href=\"/Book/20230328-%EA%B0%80%EC%83%81%EB%A9%B4%EC%A0%91_Chapter6/#cap-%EC%A0%95%EB%A6%AC\"><strong>CAP 정리</strong></a></li>\n</ul>\n</li>\n<li>\n<p><a href=\"/Book/20230328-%EA%B0%80%EC%83%81%EB%A9%B4%EC%A0%91_Chapter6/#%EC%8B%9C%EC%8A%A4%ED%85%9C-%EC%BB%B4%ED%8F%AC%EB%84%8C%ED%8A%B8\">시스템 컴포넌트</a></p>\n<ul>\n<li><a href=\"/Book/20230328-%EA%B0%80%EC%83%81%EB%A9%B4%EC%A0%91_Chapter6/#%EB%8D%B0%EC%9D%B4%ED%84%B0-%ED%8C%8C%ED%8B%B0%EC%85%98\">데이터 파티션</a></li>\n<li><a href=\"/Book/20230328-%EA%B0%80%EC%83%81%EB%A9%B4%EC%A0%91_Chapter6/#%EB%8D%B0%EC%9D%B4%ED%84%B0-%EB%8B%A4%EC%A4%91%ED%99%94-replication\">데이터 다중화 (Replication)</a></li>\n<li><a href=\"/Book/20230328-%EA%B0%80%EC%83%81%EB%A9%B4%EC%A0%91_Chapter6/#%EC%9D%BC%EA%B4%80%EC%84%B1-consistency\">일관성 (Consistency)</a></li>\n<li><a href=\"/Book/20230328-%EA%B0%80%EC%83%81%EB%A9%B4%EC%A0%91_Chapter6/#%EC%9D%BC%EA%B4%80%EC%84%B1-%EB%B6%88%EC%9D%BC%EC%B9%98-%ED%95%B4%EC%86%8C-inconsistency-resolution\">일관성 불일치 해소 (Inconsistency Resolution)</a></li>\n<li><a href=\"/Book/20230328-%EA%B0%80%EC%83%81%EB%A9%B4%EC%A0%91_Chapter6/#%EC%9E%A5%EC%95%A0-%EC%B2%98%EB%A6%AC\">장애 처리</a></li>\n<li><a href=\"/Book/20230328-%EA%B0%80%EC%83%81%EB%A9%B4%EC%A0%91_Chapter6/#%EC%8B%9C%EC%8A%A4%ED%85%9C-%EC%95%84%ED%82%A4%ED%83%9D%EC%B2%98\">시스템 아키택처</a></li>\n<li><a href=\"/Book/20230328-%EA%B0%80%EC%83%81%EB%A9%B4%EC%A0%91_Chapter6/#%EC%93%B0%EA%B8%B0-%EA%B2%BD%EB%A1%9C\">쓰기 경로</a></li>\n<li><a href=\"/Book/20230328-%EA%B0%80%EC%83%81%EB%A9%B4%EC%A0%91_Chapter6/#%EC%9D%BD%EA%B8%B0-%EA%B2%BD%EB%A1%9C\">읽기 경로</a></li>\n</ul>\n</li>\n</ul>","frontmatter":{"date":"2023년 03월 28일","title":"[가상 면접 사례로 배우는 대규모 시스템 설계 기초] 6장. 키-값 저장소 설계","tags":["가상 면접 사례로 배우는 대규모 시스템 설계 기초"]}}},"pageContext":{"slug":"/Book/20230328-가상면접_Chapter6/","previous":{"fields":{"slug":"/Book/20230323-가상면접_Chapter4/"},"frontmatter":{"title":"[가상 면접 사례로 배우는 대규모 시스템 설계 기초] 4장. 처리율 제한 장치의 설계"}},"next":{"fields":{"slug":"/Spring-WebFlux/20230406-[통합] Reactive Stream 부터 WebFlux까지 개념 파헤쳐보기/"},"frontmatter":{"title":"[통합] Reactive Stream 부터 WebFlux까지 개념 파헤쳐보기"}}}},"staticQueryHashes":["3911196313","4111100897"]}